server:
  port: 9002
  shutdown: graceful
  netty:
    connection-timeout: 10s

spring:
  application:
    name: order-service
  lifecycle:
    timeout-per-shutdown-phase: 15s
  cloud:
    function:
      definition: dispatchOrder
    stream:
      # Since there isn't any acceptOrder function, we trigger the framework
      # to create the source bidings via the spring.cloud.stream.source property.
      # The bindings name for this external source will not be derived from a function
      # name but the name provided by the configuration.
      source: acceptOrder
      # Kafka common properties (ex.: destination, contentType)
      bindings:
        dispatchOrder-in-0:
          destination: order-dispatched
          group: ${spring.application.name}
        acceptOrder-out-0:
          destination: order-accepted

  kafka:
    bootstrap-servers: ${kafka_bootstrap_servers:localhost:9092}
    properties:
      sasl:
        jaas:
          config: org.apache.kafka.common.security.plain.PlainLoginModule required username=${kafka_username:'admin'} password=${kafka_password:'admin-secret'};
        mechanism: PLAIN
      security:
        protocol: SASL_PLAINTEXT
    consumer:
      auto-offset-reset: earliest
      group-id: ${spring.application.name}
      key-deserializer: org.apache.kafka.common.serialization.LongDeserializer
      value-deserializer: org.apache.kafka.common.serialization.ByteArrayDeserializer
      max-poll-records: 1
      fetch-max-wait: 36000
      # Makes the container send the offset information to Kafka transaction ony when
      # MessageListener ends without error
      enable-auto-commit: false
      # Only allows consumers to consume messages whose transaction is committed, or
      # those messages sent without a transaction at all.
      # Kafka won't allow consumers to read messages whose transactions are aborted/rollback
      isolation-level: read_committed
      client-id: ${spring.application.name}
    producer:
      transaction-id-prefix: tx-
      properties:
        enable.idempotence: true
        transactional.id: tran-id-1
#      client-id: ${spring.application.name}
#      enable:
#        idempotence: true
#        transactional:
#          id: "prod-1"
#      key-serializer: org.apache.kafka.common.serialization.StringSerializer
#      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
#      retries: 2
#      stream:
#        properties:
#          spring:
#            json:
#              trusted:
#                packages: '*'
#              add:
#                type:
#                  headers: false
    jaas:
      enabled: true
    listener:
      poll-timeout: 1800000
      concurrency: 1
      ack-mode: manual_immediate
  config:
    active:
      on-profile: mysqldev
    enabled: true
    import: "optional:configserver:"
  r2dbc:
    username: order_user
    password: TXlzcWwzMjFPcmRlcg==
    url: r2dbc:mysql://${DB_HOST:localhost}:3306/${DB_NAME:polardb_catalog}?useSSL=false&allowPublicKeyRetrieval=true
    pool:
      max-create-connection-time: 2s
      initial-size: 5
      max-size: 10
  flyway:
    user: ${spring.r2dbc.username}
    password: ${spring.r2dbc.password}
    url: jdbc:mysql://${DB_HOST:localhost}:3306/${DB_NAME:polardb_catalog}?useSSL=false&allowPublicKeyRetrieval=true
    table: order_service_flyway_schema_history
    baseline-on-migrate: true
    baseline-version: 0
    locations: classpath:mysqlmigrations

polar:
  catalog-service-uri: "http://localhost:9001"
  client-time-out: 5